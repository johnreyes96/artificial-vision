# -*- coding: utf-8 -*-
"""ImageBasics__16_08_2022.ipynb

Automatically generated by Colaboratory.

12/08/2022 -- Utilidades para la carga y visualización de imágenes.

(a.) Librerías para los códigos que se implemetarán.
"""

from PIL import Image
# Importar numpy para dar soporte a:
# Concatenación de matrices - np.concatenate
import numpy as np
# Importar el módulo cv2 de la librería opencv
import cv2
# Soporte para visualización.
import matplotlib.pyplot as plt

"""(b.) Carga de una imagen desde una ubicación en la carpeta Drive. Para esto se debe enlazar Colaboratory con la 
carpeta Drive de la cuenta."""

# Se debe buscar la ruta correcta para leer una imagen
im1 = cv2.imread('../../data/kodim05.png', cv2.IMREAD_COLOR)  # IMREAD_GRAYSCALE
# im1 = cv2.cvtColor(im1, cv2.COLOR_BGR2RGB) # OpenCV usa el ordenamiento BGR por defecto, mientras que matplotlib
# asume RGB.

# Referencia para línea 2: https://stackoverflow.com/questions/39316447/opencv-giving-wrong-color-to-colored-images
# -on-loading

"""(c.) Visualización de la imagen y sus componentes de color. Se pueden utilizar varias funciones. Una posible 
opxión es usar imshow de la librería Matplotlib. Referencia: 
https://matplotlib.org/stable/tutorials/introductory/images.html

Tener presente que la paleta de color que se usa por defecto al invocar esta función. Evaluar esto mostrando por 
separado las componentes de color de la imagen RGB original."""

# En este caso se usa una función de la librería Matplotlib
imgplot = plt.imshow(im1, cmap="gray")
plt.savefig("../../output/kodim05_rgb.png")
plt.show()

R = im1[:, :, 0]
G = im1[:, :, 1]
B = im1[:, :, 2]

imgplotR = plt.imshow(R, cmap="gray")
plt.colorbar()  # Considere el uso de una barra de color para ver los valores mínimo y máximo en la imagen que se está
# mostrando.
# Otras paletas de colores disponibles para imshow: https://matplotlib.org/stable/tutorials/colors/colormaps.html
plt.savefig("../../output/kodim05_gray.png")
plt.show()

"""(d.) Mezclado de dos imágenes en escala de grises basado en operaciones ariméticas. La carga en escala de grises 
se puede hacer directamente con cv2-imread(... ,cv2.IMREAD_GRAYSCALE). Utilice la expresión C = kA - (1 - k)B, 
con 0 <= k <= 1."""

A = cv2.imread('../../data/Cameraman.png', cv2.IMREAD_GRAYSCALE)
A = A[0:1024, 0:1022]
B = cv2.imread('../../data/Rice.png', cv2.IMREAD_GRAYSCALE)
k = 0.5
C = (k * A) + ((1 - k) * B)

imgplotC = plt.imshow(C, cmap="gray")
plt.savefig("../../output/Cameraman_Rice.png")
plt.show()
# MatLab Reshape -> WARNING: para hacerlo en python

"""(e.) Obtenga una composición con las dos imágenes de punto (d.) Esta vez, la composición consistirá en que una de 
las imágenes, concretamente una versión reducida, estará en la esquina inferior derecha de la otra imagen. 
**Extra-clase:** Generar el mismo efecto sugerido en (e.) pero con una secuencias de imágenes. Consultar cómo 
reproducir la secuencia de imágenes resultate a una velocidad de 30 fps."""

im1 = Image.open('../../data/Cameraman.png')
im2 = Image.open('../../data/Rice.png')

basewidth = 342  # set new width
wpercent = (basewidth / float(im2.size[0]))
hsize = int((float(im2.size[1]) * float(wpercent)))
im2 = im2.resize((basewidth, hsize), Image.LANCZOS)  # scale image

width_im1, height_im1 = im1.size
width_im2, height_im2 = im2.size

im1.paste(im2, (width_im1 - width_im2, height_im1 - height_im2), im2)  # set im2 in corner
im1.save('../../output/Cameraman_Rice_composition_process.png', quality=95)

composition = cv2.imread('../../output/Cameraman_Rice_composition_process.png', cv2.IMREAD_GRAYSCALE)
imgplotGG = plt.imshow(composition, cmap="gray")
plt.savefig("../../output/Cameraman_Rice_composition.png")
plt.show()

"""(f.) Obtenga el operador inverso de una imagen, el cual se define como sigue: I_inv = max(I) - I.

En python: Escalar le resta una matriz -> func para calcular el máximo de la imagen: numpy.invert(matriz)
"""

invA = np.invert(np.copy(A))
imgplotC = plt.imshow(invA, cmap="gray")
plt.savefig("../../output/Cameraman_Rice_movie.png")
plt.show()

"""(g.) Implemente el operador umbral para imágenes en escala de grises."""

thrIm = np.copy(A)
thr = 127
thrIm[A <= thr] = 0
thrIm[A > thr] = 1
imgplotD = plt.imshow(thrIm, cmap="gray")
plt.savefig("../../output/Cameraman_umbral.png")
plt.show()
