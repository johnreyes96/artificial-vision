# -*- coding: utf-8 -*-
"""HistogramAndContrast.ipynb

Automatically generated by Colaboratory.
"""

# Importar numpy para dar soporte a:
# Concatenación de matrices - np.concatenate
import numpy as np
# Importar el módulo cv2 de la librería opencv
import cv2
# Soporte para visualización.
import matplotlib.pyplot as plt

"""
(a.) Enlazar Google Drive y cargar imagen en variable."""

# Se debe conectar con el Drive, y luego buscar la ruta correcta para leer la imagen
imagenEntrada = cv2.imread('../../data/HCColor2.jpg', cv2.IMREAD_COLOR)  # Considerar la 4, 4a, 5
imagenEntrada = cv2.cvtColor(imagenEntrada, cv2.COLOR_BGR2RGB)  # OpenCV usa el ordenamiento BGR por defecto,
# mientras que matplotlib asume RGB.

# plotInputIm = plt.imshow(imagenEntrada, cmap="gray", vmin=0, vmax=255)

print(np.min(imagenEntrada))
print(np.max(imagenEntrada))

"""(b.) Calcular el histograma para la imagen mostrada arriba. Crear una función que haga dicho cálculo, 
sin necesidad de acceder a todas las filas/columnas de la image. Comparar resultado con funciones propias de Python."""


# Principio de operación de la función que modifica el contraste:

# INICIO - función
def fnHistoContrastEnhance(input_im, out_min, out_max):
    outIm = 0 * input_im  # Imagen de salida. Tiene el mismo tamaño de la de entrada, y que ambas están en escala de grises.
    inMin = np.min(input_im)  # x1
    inMax = np.max(input_im)  # x2
    # y1 e y2 son argumentos de entrada de la función
    # y1 = outMin
    # y2 = outMax

    # Inicio: algoritmo para modificar contraste.
    m = (out_max - out_min) / (inMax - inMin)
    pixelInputVal = range(inMin, inMax)
    for pixelValue in pixelInputVal:
        outIm[input_im == pixelValue] = (m * (pixelValue - inMin)) + out_min

    return outIm


# Final: algoritmo para modificar contraste.
# FINAL - Función

# INICIO - función que calcula el histograma de una imagen.
def fnHistograma(input_im):
    vHistograma = np.zeros((1, 256))
    pixelRange = range(0, 255)

    for pixelValue in pixelRange:  # Algoritmo para la función propuesto en (2.):
        vHistograma[0, pixelValue] = (
                input_im == pixelValue).sum()  # https://aarsh.dev/2017/10/15/python-numpy-count-elements/

    return vHistograma


# FINAL - Función

imContrastEnhanced = fnHistoContrastEnhance(imagenEntrada, 0, 255)

# Caso donde la imagen está en escala de grises
histoImagenEnt = fnHistograma(imagenEntrada)
histoImagenEnt = list(histoImagenEnt.flatten())

histoImagenOut = fnHistograma(imContrastEnhanced)
histoImagenOut = list(histoImagenOut.flatten())

"""Visualización de las imágenes de entrada y salida."""

# plt.rcParams["figure.figsize"] = [20,20]
f, axarr = plt.subplots(1, 2)  # https://stackoverflow.com/questions/41793931/plotting-images-side-by-side-using-matplotlib
axarr[0].imshow(imagenEntrada, cmap="gray", vmin=0, vmax=255)
axarr[1].imshow(imContrastEnhanced, cmap="gray", vmin=0, vmax=255)
plt.savefig("../../output/HCColor2_saturation.png")
plt.show()

"""Visualización del histogramas: imagen de entrada y de salida."""

valsPixel = np.arange(256)
# creating the bar plot:
fig, axs = plt.subplots(1, 2, figsize=(12, 4), sharey=True)
axs[0].bar(valsPixel, histoImagenEnt, align='center', width=1)
axs[1].bar(valsPixel, histoImagenOut, align='center', width=1)
plt.savefig("../../output/HCColor2_histogram.png")
plt.show()

"""Tarea: Programar en una única función, disminución y aumento del contraste, verificar visualmente y en los 
histogramas de imágenes de entrada y salida"""


# Principio de operación de la función que modifica el contraste:

# INICIO - función
def fnHistoContrastEnhance(input_im, out_min, out_max, inc):
    outIm = 0 * input_im  # Imagen de salida. Tiene el mismo tamaño de la de entrada, y que ambas están en escala de grises.
    inMin = np.min(input_im)  # x1
    inMax = np.max(input_im)  # x2
    # y1 e y2 son argumentos de entrada de la función
    # y1 = outMin
    # y2 = outMax

    # Inicio: algoritmo para modificar contraste.
    pixelInputVal = range(inMin, inMax)

    if inc:
        for pixelValue in pixelInputVal:
            outIm[input_im == pixelValue] = ((out_max - out_min) / (inMax - inMin)) * (pixelValue - inMin) + out_min
    else:
        for pixelValue in pixelInputVal:
            outIm[input_im == pixelValue] = ((pixelValue - inMin) / (inMax - inMin)) * (out_max - out_min) + out_min

    print(outIm)
    return outIm


# Final: algoritmo para modificar contraste.
# FINAL - Función

# INICIO - función que calcula el histograma de una imagen.
def fnHistograma(input_im):
    vHistograma = np.zeros((1, 256))
    pixelRange = range(0, 255)

    for pixelValue in pixelRange:  # Algoritmo para la función propuesto en (2.):
        vHistograma[0, pixelValue] = (
                input_im == pixelValue).sum()  # https://aarsh.dev/2017/10/15/python-numpy-count-elements/

    return vHistograma


# FINAL - Función

imagenEntrada = cv2.imread('../../data/HCColor2.jpg', cv2.IMREAD_GRAYSCALE)

imContrastEnhanced = fnHistoContrastEnhance(imagenEntrada, 0, 100, True)
imContrastEnhanced2 = fnHistoContrastEnhance(imagenEntrada, 0, 100, False)

# Caso donde la imagen está en escala de grises
histoImagenEnt = fnHistograma(imagenEntrada)
histoImagenEnt = list(histoImagenEnt.flatten())

histoImagenOut = fnHistograma(imContrastEnhanced)
histoImagenOut = list(histoImagenOut.flatten())

_, axarr = plt.subplots(1, 2)  # https://stackoverflow.com/questions/41793931/plotting-images-side-by-side-using-matplotlib
axarr[0].imshow(imagenEntrada, cmap="gray", vmin=0, vmax=255)
axarr[1].imshow(imContrastEnhanced, cmap="gray", vmin=0, vmax=255)
plt.savefig("../../output/HCColor2_contrast.png")
plt.show()

_, axarr = plt.subplots(1, 2)  # https://stackoverflow.com/questions/41793931/plotting-images-side-by-side-using-matplotlib
axarr[0].imshow(imagenEntrada, cmap="gray", vmin=0, vmax=255)
axarr[1].imshow(imContrastEnhanced2, cmap="gray", vmin=0, vmax=255)
plt.savefig("../../output/HCColor2_contrast2.png")
plt.show()
